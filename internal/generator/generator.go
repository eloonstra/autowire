package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"path/filepath"
	"sort"
	"strings"

	"github.com/eloonstra/autowire/internal/analyzer"
	"github.com/eloonstra/autowire/internal/types"
)

func Generate(r *analyzer.Result) ([]byte, error) {
	var buf bytes.Buffer
	out := r.OutputImportPath
	imports := r.Imports

	buf.WriteString("// Code generated by autowire. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", r.PackageName))

	writeImports(&buf, imports)
	writeAppStruct(&buf, r.Providers, out, imports)
	buf.WriteString("\n")
	writeInitFunc(&buf, r, out, imports)

	return format.Source(buf.Bytes())
}

func writeImports(buf *bytes.Buffer, imports map[string]string) {
	if len(imports) == 0 {
		return
	}

	paths := make([]string, 0, len(imports))
	for p := range imports {
		paths = append(paths, p)
	}
	sort.Strings(paths)

	buf.WriteString("import (\n")
	for _, p := range paths {
		alias := imports[p]
		if alias == "" {
			buf.WriteString(fmt.Sprintf("\t%q\n", p))
			continue
		}
		buf.WriteString(fmt.Sprintf("\t%s %q\n", alias, p))
	}
	buf.WriteString(")\n\n")
}

func writeAppStruct(buf *bytes.Buffer, providers []types.Provider, out string, imports map[string]string) {
	buf.WriteString("type App struct {\n")
	for _, p := range providers {
		buf.WriteString(fmt.Sprintf("\t%s %s\n", toUpper(p.VarName), formatType(p.ProvidedType, out, imports)))
	}
	buf.WriteString("}\n")
}

func writeInitFunc(buf *bytes.Buffer, r *analyzer.Result, out string, imports map[string]string) {
	buf.WriteString("func InitializeApp() (*App, error) {\n")

	vars := make(map[string]string)

	if len(r.Providers) > 0 {
		buf.WriteString("\t// provide\n")
		for _, p := range r.Providers {
			writeProvider(buf, p, vars, out, imports)
			vars[p.ProvidedType.Key()] = p.VarName
		}
	}

	if len(r.Invocations) > 0 {
		buf.WriteString("\n\t// invoke\n")
		for _, inv := range r.Invocations {
			writeInvocation(buf, inv, vars, out, imports)
		}
	}

	buf.WriteString("\treturn &App{\n")
	for _, p := range r.Providers {
		buf.WriteString(fmt.Sprintf("\t\t%s: %s,\n", toUpper(p.VarName), p.VarName))
	}
	buf.WriteString("\t}, nil\n")
	buf.WriteString("}\n")
}

func writeProvider(buf *bytes.Buffer, p types.Provider, vars map[string]string, out string, imports map[string]string) {
	switch p.Kind {
	case types.ProviderKindStruct:
		writeStructInit(buf, p, vars, out, imports)
	case types.ProviderKindFunc:
		writeFuncInit(buf, p, vars, out, imports)
	}
}

func writeStructInit(buf *bytes.Buffer, p types.Provider, vars map[string]string, out string, imports map[string]string) {
	typeName := formatType(p.ProvidedType, out, imports)
	typeName = strings.TrimPrefix(typeName, "*")

	if len(p.Dependencies) == 0 {
		buf.WriteString(fmt.Sprintf("\t%s := &%s{}\n", p.VarName, typeName))
		return
	}

	buf.WriteString(fmt.Sprintf("\t%s := &%s{\n", p.VarName, typeName))
	for _, dep := range p.Dependencies {
		buf.WriteString(fmt.Sprintf("\t\t%s: %s,\n", dep.FieldName, vars[dep.Type.Key()]))
	}
	buf.WriteString("\t}\n")
}

func writeFuncInit(buf *bytes.Buffer, p types.Provider, vars map[string]string, out string, imports map[string]string) {
	args := makeArgs(p.Dependencies, vars)
	fn := qualifiedName(p.Name, p.ImportPath, out, imports)

	if p.CanError {
		buf.WriteString(fmt.Sprintf("\t%s, err := %s(%s)\n", p.VarName, fn, args))
		buf.WriteString("\tif err != nil {\n\t\treturn nil, err\n\t}\n\n")
		return
	}
	buf.WriteString(fmt.Sprintf("\t%s := %s(%s)\n", p.VarName, fn, args))
}

func writeInvocation(buf *bytes.Buffer, inv types.Invocation, vars map[string]string, out string, imports map[string]string) {
	args := make([]string, len(inv.Dependencies))
	for i, dep := range inv.Dependencies {
		args[i] = vars[dep.Key()]
	}
	fn := qualifiedName(inv.Name, inv.ImportPath, out, imports)
	argStr := strings.Join(args, ", ")

	if inv.CanError {
		buf.WriteString(fmt.Sprintf("\tif err := %s(%s); err != nil {\n\t\treturn nil, err\n\t}\n\n", fn, argStr))
		return
	}
	buf.WriteString(fmt.Sprintf("\t%s(%s)\n", fn, argStr))
}

func makeArgs(deps []types.Dependency, vars map[string]string) string {
	args := make([]string, len(deps))
	for i, dep := range deps {
		args[i] = vars[dep.Type.Key()]
	}
	return strings.Join(args, ", ")
}

func pkgName(importPath string, imports map[string]string) string {
	if alias := imports[importPath]; alias != "" {
		return alias
	}
	return filepath.Base(importPath)
}

func formatType(t types.TypeRef, out string, imports map[string]string) string {
	prefix := ""
	if t.IsPointer {
		prefix = "*"
	}
	if t.ImportPath == "" || t.ImportPath == out {
		return prefix + t.Name
	}
	return prefix + pkgName(t.ImportPath, imports) + "." + t.Name
}

func qualifiedName(name, importPath, out string, imports map[string]string) string {
	if importPath == out {
		return name
	}
	return pkgName(importPath, imports) + "." + name
}

func toUpper(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}
